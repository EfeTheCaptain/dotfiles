#!/bin/bash

# Function to clean up on exit
cleanup() {
    [ -n "$tmpfile" ] && rm -f "$tmpfile"
}
trap cleanup EXIT

# Function to check if required tools are installed
check_dependencies() {
    local missing=()
    for cmd in yt-dlp jq fzf mpv ffmpeg; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+=("$cmd")
        fi
    done
    
    if [ ${#missing[@]} -gt 0 ]; then
        echo "Error: The following required tools are not installed:"
        printf ' - %s\n' "${missing[@]}"
        echo "Please install them before running this script."
        exit 1
    fi
}

# Function to check internet connection
check_internet() {
    if ! curl -Is https://www.youtube.com | head -n 1 | grep -q "HTTP/.* 200"; then
        echo "Error: No internet connection or YouTube is not reachable."
        exit 1
    fi
}

# Check for required tools and internet connection before proceeding
check_dependencies
check_internet

# Get search query from the user
read -rp "ðŸ” Search YouTube: " query
[ -z "$query" ] && exit 1

# Create temp file for results
tmpfile=$(mktemp) || { echo "Error: Could not create temp file"; exit 1; }

# Fetch results as JSON array with error handling
echo "Searching YouTube for '$query'..."
if ! yt-dlp --flat-playlist --default-search "ytsearch5" -j "$query" 2>"$tmpfile.err" | jq -s '.' > "$tmpfile"; then
    echo "Error: Search failed. Details:"
    cat "$tmpfile.err"
    exit 1
fi

# Check for HTTP errors in yt-dlp output
if grep -q "HTTP Error" "$tmpfile.err"; then
    echo "Error: YouTube API request failed:"
    grep "HTTP Error" "$tmpfile.err" | head -n 1
    exit 1
fi

# Read results from the temp file
results=$(cat "$tmpfile")
if [ -z "$results" ] || [ "$results" = "[]" ]; then
    echo "Error: No results found for your query."
    exit 1
fi

# Format results for display with proper duration handling
formatted_results=$(jq -r '.[] |
    ((.duration? // 0) | tonumber | strftime("%M:%S")) as $dur |
    "[\($dur)] \(.title)"' "$tmpfile")

# Select with fzf
selected=$(echo "$formatted_results" | fzf --height=40% --reverse --cycle --prompt="Select song: " --bind 'ctrl-c:abort')
[ -z "$selected" ] && exit 0  # Exit if no selection made

# Extract clean title (handles special characters and trims spaces)
title=$(echo "$selected" | sed -E 's/^\[[^]]*\] //' | sed 's/[[:space:]]*$//')

# Get URL by matching exact title from original results
url=$(jq -r --arg t "$title" '
    .[] |
    select(.title == $t) |
    .webpage_url' "$tmpfile")

# Print the extracted URL for debugging purposes
echo "Extracted URL: $url"

# Play with comprehensive error checking
if [ -n "$url" ]; then
    echo "Now Playing: $title"
    
    # Check if URL is valid
    if [[ ! "$url" =~ ^https?:// ]]; then
        echo "Error: Invalid URL format: $url"
        exit 1
    fi
    
    # Try to play with mpv, with various fallbacks and error handling
    if ! mpv --no-video \
             --ao=alsa \
             --http-persistent=yes \
             --http-retries=infinite \
             --cache=yes \
             --ytdl-format="bestaudio/best" \
             --script-opts=ytdl_hook-try_ytdl_first=yes \
             "$url" 2>&1 | tee "$tmpfile.err"; then
        
        echo "Error: Playback failed for $title."
        
        # Check for common errors
        if grep -q "ffmpeg" "$tmpfile.err"; then
            echo "FFmpeg error detected. Please ensure ffmpeg is properly installed."
        fi
        
        if grep -q "Failed to open" "$tmpfile.err"; then
            echo "Network error detected. Please check your internet connection."
        fi
        
        if grep -q "unsupported protocol" "$tmpfile.err"; then
            echo "Protocol error. The URL might be malformed."
        fi
        
        exit 1
    fi
else
    echo "Error: Could not extract URL for: $title."
    exit 1
fi
